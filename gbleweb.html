<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GS BLE - gbleWeb v.g.2.7.28</title>
  <style>
   /* --- LOCKED STATUS TABLE (LA) ---
      Area             | Status  | Core Rules (Updated for v.g.2.0)
      -----------------------------------------------------------------------------
      Header           | LOCKED  | Logo, Title, and Versioning Format (vx_y_MMDD).
      UI Layout        | LOCKED  | CSS Variables, Margins, and Body Height (100vh).
      Toolbar          | UNLOCKED| Clear Data, Record, and Replay logic synced.
      Wave Area        | LOCKED  | 260px Height, Absolute Controls, Backdrop-filter.
      X/Y/Z Cards (L)  | LOCKED  | Left block: X, Y, Z values, P-P, and RMS.
      Total Card (M)   | LOCKED  | Middle block: Total value with Triggered-bg logic.
      Icon Grid (R-Top)| LOCKED  | Right-Top 3x3 Grid for Direction/Flip icons.
      Info Area (Left) | UNLOCKED| Bottom-Left: Status/Log messages.
      CW Area (R-Bot)  | LOCKED  | Bottom-Right: Forward/Reverse and RPM (50/50 Split).
   */

    /* --- LOCKED AREA: BASE & HEADER --- */
    :root { --primary: #4f46e5; --bg: #f3f4f6; --border: #e5e7eb; --text: #111827; --muted: #6b7280; --deep-gray: #666666; }
    body { margin: 0; background-color: var(--bg); font-family: -apple-system, sans-serif; color: var(--text); overflow: hidden; height: 100vh; }
    .app-header { background: white; padding: 2px 18px; border-bottom: 1px solid var(--border); height: 60px; box-sizing: border-box; }
    .app-header-inner { max-width: 95%; margin: auto; display: flex; align-items: center; justify-content: space-between; height: 100%; }
    .app-logo { height: 48px; width: auto; }
    .app-title { font-size: 20px; font-weight: 700; color: #b91c1c; }
    .layout { max-width: 95%; margin: 10px auto; padding: 0 16px; height: calc(100vh - 80px); display: flex; flex-direction: column; gap: 10px; box-sizing: border-box; }
    
    /* --- TOOLBAR --- */
    .toolbar { display: flex; align-items: center; justify-content: space-between; flex-shrink: 0; background: transparent; padding: 4px 0px; border: none !important; }
    .toolbar-left { display: flex; align-items: center; gap: 15px; }
    .toolbar-section { display: flex; align-items: center; gap: 8px; }
    .section-divider { width: 1px; height: 20px; background: #d1d5db; margin: 0 4px; }
    .btn { padding: 6px 14px; font-size: 13px; border-radius: 6px; cursor: pointer; border: 0 !important; background: #e2e8f0; font-weight: 600; color: var(--text); outline: none !important; transition: all 0.2s; }
    .btn:hover:not(:disabled) { background: #cbd5e1; }
    .btn-primary { background: var(--primary); color: white; }
    .btn-active { background: #fde68a; color: #92400e; }
    .btn-danger { background: #fee2e2; color: #b91c1c; border: 1px solid #fecaca !important; }
    .btn-record.recording { background: #ef4444; color: white; animation: blink 1.5s infinite; }
    
    /* Learning Button Style */
    .btn-learning { background: #8b5cf6; color: white; border: 1px solid #7c3aed !important; }
    .btn-learning:hover { background: #7c3aed; }
    .btn-learning-active { background: #6d28d9; color: white; animation: pulse 1.5s infinite; border: 1px solid #5b21b6 !important; }
    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.8; } 100% { opacity: 1; } }
    @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }
    .btn:disabled { background: #f1f5f9; color: #cbd5e1; cursor: not-allowed; opacity: 0.6; }
    
    #fileInfoDisplay { font-size: 12px; color: var(--deep-gray); font-weight: bold; margin-right: 10px; display: none; }

    /* --- LOCKED AREA: WAVE AREA --- */
    .wave-wrap { background: white; border-radius: 12px; border: 1px solid var(--border); padding: 12px; position: relative; height: 260px; flex-shrink: 0; box-sizing: border-box; }
    .wave-controls-left { position: absolute; top: 12px; left: 15px; display: flex; gap: 15px; z-index: 10; background: rgba(255,255,255,0.85); padding: 6px 12px; border-radius: 8px; backdrop-filter: blur(4px); }
    .wave-controls-right { position: absolute; top: 12px; right: 15px; display: flex; gap: 15px; z-index: 10; background: rgba(255,255,255,0.85); padding: 6px 12px; border-radius: 8px; backdrop-filter: blur(4px); align-items: center; }
    .btn-calib { background: #fee2e2; color: #b91c1c; font-size: 12px; padding: 4px 12px; font-weight: bold; }
    .setting-item { display: flex; align-items: center; gap: 6px; font-size: 13px; font-weight: 700; color: var(--text); }
    .setting-select { padding: 3px 6px; font-size: 13px; border-radius: 4px; border: 0 !important; background: #f1f5f9; cursor: pointer; font-weight: bold; }
    .wave-check { display: flex; align-items: center; gap: 6px; font-size: 13px; font-weight: bold; cursor: pointer; }
    canvas { width: 100%; height: 100%; background: #ffffff; border-radius: 6px; display: block; }

    /* --- LOCKED AREA: SIGNAL TABLE --- */
    .signal-area { display: flex; flex-direction: column; gap: 8px; flex-shrink: 0; }
    .signal-top-row { display: flex; gap: 12px; height: 180px; }
    .xyz-container, .total-container, .icon-xyz-container { flex: 1; display: flex; flex-direction: column; }
    .icon-xyz-container { gap: 8px; }
    .card-small, .card-total { background: white; border-radius: 12px; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
    .card-small { padding: 6px 14px; flex: 1; display: flex; flex-direction: column; justify-content: center; margin-bottom: 4px; }
    .card-total { padding: 10px; flex: 1; text-align: center; display: flex; flex-direction: column; justify-content: center; }
    .card-total.triggered-bg { background-color: #fee2e2 !important; }
    .icon-grid-wrap { background: white; border-radius: 12px; padding: 10px; flex: 1; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
    .icon-grid { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 6px; height: 100%; }
    .status-icon { background: rgba(226, 232, 240, 0.4); border-radius: 10px; display: flex; align-items: center; justify-content: center; color: rgba(148, 163, 184, 0.6); font-weight: 900; font-size: 13px; }
    .status-icon.active { background: #ffedd5 !important; color: #9a3412 !important; }
    .status-icon.active-z { background: #dbeafe !important; color: #1e40af !important; }
    .label { font-size: 14px; font-weight: 900; color: #4b5563; display: flex; align-items: center; gap: 5px; }
    .label-x::before { content: ""; width: 3px; height: 10px; background: #ef4444; border-radius: 2px; }
    .label-y::before { content: ""; width: 3px; height: 10px; background: #22c55e; border-radius: 2px; }
    .label-z::before { content: ""; width: 3px; height: 10px; background: #3b82f6; border-radius: 2px; }
    .label-t::before { content: ""; width: 3px; height: 10px; background: #000; border-radius: 2px; }
    .value { font-family: 'Courier New', monospace; font-weight: 900; font-size: 26px; line-height: 1.1; }
    .card-total .value { font-size: 42px; color: #000; }
    .stats-row { display: flex; gap: 8px; margin-top: 2px; border-top: 1px dashed #eee; justify-content: center; }
    .stat-val { font-size: 13px; font-family: monospace; font-weight: 700; color: #374151; }

    /* --- LOCKED AREA: BOTTOM INFO & CW --- */
    .info-layout { display: flex; gap: 12px; flex: 1; min-height: 0; }
    .info-area { flex: 1; background: #ffffff; border: 1px dashed #cbd5e1; border-radius: 12px; overflow-y: auto; padding: 10px; font-size: 12px; display: flex; flex-direction: column; font-family: 'Consolas', monospace; }
    .log-line { margin-bottom: 2px; border-bottom: 1px solid #f1f5f9; padding-bottom: 2px; color: #333; }
    
    .cw-area-wrap {
        background: white; border-radius: 12px; box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        display: flex; align-items: stretch; overflow: hidden; height: 100%;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
    }
    .cw-area-wrap:hover { box-shadow: 0 4px 6px rgba(0,0,0,0.1); transform: translateY(-1px); }
    .cw-area-wrap:active { transform: translateY(0); }
    
    .cw-area-wrap.disabled {
        background: #f3f4f6;
        border: 1px solid #d1d5db;
        opacity: 0.6;
        filter: grayscale(100%);
    }
    .cw-area-wrap.disabled::after {
        content: "DISABLED";
        position: absolute;
        top: 50%; left: 50%; transform: translate(-50%, -50%);
        font-weight: 900; color: #6b7280; font-size: 24px; opacity: 0.3;
        pointer-events: none;
    }

    .cw-section { flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; border-right: 1px solid #f1f5f9; }
    .cw-label { font-size: 11px; font-weight: 900; color: var(--muted); margin-bottom: 2px; }
    .cw-value { font-family: 'Courier New', monospace; font-weight: 900; font-size: 24px; }

    #cwDebugInfo {
        position: absolute;
        bottom: 4px;
        width: 100%;
        text-align: center;
        font-size: 10px;
        color: #bdc3c7;
        font-family: monospace;
        pointer-events: none;
        opacity: 0.8;
    }
  </style>
</head>
<body>

<header class="app-header">
  <div class="app-header-inner">
    <div style="display:flex; align-items:center; gap:10px;">
      <img class="app-logo" src="eup-logo.png" alt="Logo">
      <span class="app-title">弋揚 GS BLE 測試介面</span>
    </div>
    <div style="color:var(--muted); font-size:12px;">v.g.2.7.28_0204_DataTimeFix</div>
  </div>
</header>

<main class="layout">
  <div class="toolbar">
    <div class="toolbar-left">
      <div class="toolbar-section">
        <button id="liveModeBtn" class="btn btn-active">LIVE 模式</button>
        <button id="logModeBtn" class="btn">LOG 模式</button>
      </div>
      <div class="section-divider"></div>
      <div id="liveControls" class="toolbar-section">
        <button id="connectBtn" class="btn btn-primary">連接 BLE</button>
      </div>
      <div id="logControls" class="toolbar-section" style="display:none;">
        <input type="file" id="logFileInput" accept=".txt" style="display:none;">
        <button class="btn" onclick="document.getElementById('logFileInput').click()">載入</button>
        <button id="playBtn" class="btn" disabled>播放</button>
        <button id="pauseBtn" class="btn" disabled>暫停</button>
        <button id="resetBtn" class="btn" disabled>重置</button>
      </div>
      <div class="section-divider"></div>
      <div class="toolbar-section">
        <button id="learningBtn" class="btn btn-learning">cw_cal</button>
      </div>
    </div>
    <div class="toolbar-right" style="display:flex; gap:10px; align-items:center;">
      <div id="fileInfoDisplay"></div>
      <button id="recordBtn" class="btn btn-record" style="display:none;">開始紀錄 (00:00)</button>
      <button id="clearDataBtn" class="btn btn-danger">清除數據</button>
    </div>
  </div>

  <div class="wave-wrap">
    <div class="wave-controls-left">
      <label class="wave-check"><input type="checkbox" id="waveX" checked> <span style="color:#ef4444">X</span></label>
      <label class="wave-check"><input type="checkbox" id="waveY" checked> <span style="color:#22c55e">Y</span></label>
      <label class="wave-check"><input type="checkbox" id="waveZ" checked> <span style="color:#3b82f6">Z</span></label>
      <label class="wave-check"><input type="checkbox" id="waveT"> <span style="color:#000">總向量</span></label>
    </div>
    <div class="wave-controls-right">
      <button id="calibBtn" class="btn btn-calib">校準歸零</button>
      <div class="setting-item"><span>採樣:</span><select id="srSelect" class="setting-select"><option value="1">1:1</option><option value="5" selected>1:5</option><option value="10">1:10</option></select></div>
      <div class="setting-item"><span>平滑:</span><select id="smoothSelect" class="setting-select"><option value="off">Off</option><option value="low">Low</option><option value="mid" selected>Mid</option><option value="high">High</option></select></div>
      <div class="setting-item"><span>觸發:</span><select id="trgSelect" class="setting-select"><option value="off">Off</option><option value="0.1">0.1g</option><option value="0.2" selected>0.2g</option><option value="0.4">0.4g</option><option value="0.6">0.6g</option><option value="0.8">0.8g</option><option value="1.0">1.0g</option></select></div>
    </div>
    <canvas id="chartCanvas"></canvas>
  </div>

  <div class="signal-area">
    <div class="signal-top-row">
      <div class="xyz-container">
        <div class="card-small"><div style="display:flex;justify-content:space-between;align-items:center;"><div class="label label-x">X 軸</div><div class="value" id="valX">0.000</div></div><div class="stats-row"><div class="stat-val" id="ppX">0.000</div><div class="stat-val" id="rmsX">0.000</div></div></div>
        <div class="card-small"><div style="display:flex;justify-content:space-between;align-items:center;"><div class="label label-y">Y 軸</div><div class="value" id="valY">0.000</div></div><div class="stats-row"><div class="stat-val" id="ppY">0.000</div><div class="stat-val" id="rmsY">0.000</div></div></div>
        <div class="card-small"><div style="display:flex;justify-content:space-between;align-items:center;"><div class="label label-z">Z 軸</div><div class="value" id="valZ">0.000</div></div><div class="stats-row"><div class="stat-val" id="ppZ">0.000</div><div class="stat-val" id="rmsZ">0.000</div></div></div>
      </div>
      <div class="total-container">
        <div class="card-total" id="totalCard">
          <div class="label label-t" style="justify-content:center;">總向量值</div>
          <div class="value"><span id="valT">0.000</span><span style="font-size:16px;color:var(--muted);margin-left:4px;">G</span></div>
          <div class="stats-row"><div class="stat-val" id="ppT">0.000</div><div class="stat-val" id="rmsT">0.000</div></div>
        </div>
      </div>
      <div class="icon-xyz-container">
        <div class="icon-grid-wrap">
          <div class="icon-grid">
            <div></div><div id="iUp" class="status-icon">上</div><div></div>
            <div id="iLeft" class="status-icon">左</div><div id="iFlip" class="status-icon circle">翻轉</div><div id="iRight" class="status-icon">右</div>
            <div></div><div id="iDown" class="status-icon">下</div><div></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="info-layout">
    <div class="info-area" id="infoArea">
        <div class="log-line">系統就緒 (v.g.2.7.28_0204_DataTimeFix)</div>
    </div>
    <div style="flex: 0 0 calc(33.33% - 8px);">
      <div class="cw-area-wrap" id="cwAreaWrap" title="點擊切換偵測功能 (Click to Toggle)">
        <div class="cw-section">
            <div class="cw-label">旋轉狀態</div>
            <div class="cw-value" id="cwStatus">--</div>
        </div>
        <div class="cw-section" style="position:relative; padding:0;">
            <canvas id="rpmCanvas" style="width:100%; height:100%; display:block;"></canvas>
        </div>
        <div id="cwDebugInfo"></div>
      </div>
    </div>
  </div>
</main>

<script>
(function() {
    let bluetoothChar = null, srRatio = 5, srCounter = 0, trgTh = 0.2, trgEnabled = true;
    let offsets = {x:0, y:0, z:0}, lastRaw = {x:0, y:0, z:0}, buffer = [];
    let isLogMode = false, replayInterval = null, logLines = [];
    let smoothed = {x:0, y:0, z:0, t:0}, trgState = false, trgOnSince = 0, trgOffSince = 0;
    let currentRpm = 0, lastEventStr = "--";
    let isRecording = false, logBuffer = [], recordStartTime = 0, recordTimerInt = null;
    let playbackIdx = 0, totalLines = 0, currentFileName = "";

    // --- DETECTION SWITCH ---
    let isDetectionOn = true;

    // --- LOGIC STATE ---
    let winBuf = [];
    const WIN_SIZE = 35;

    // --- Learning State (v.g.2.7.2) ---
    let isLearning = false;
    let learnBuf = [];
    let learnedParams = {
        isValid: false,
        plane: 'YZ',
        cwSign: 1,
        rpmAxis: 'z',
        dcRef: {x:0, y:0, z:0},
        cpThreshold: 0.2 // Adaptive
    };

    // --- Animation State ---
    let spinnerAngle = 0;
    let lastAnimTime = 0;
    
    // --- V.G.2.7.28: Global Timer Variables (Data Timestamp) ---
    let lastCrossTime = 0; // Data timestamp (winBuf.t) of last zero crossing
    let hasCrossed = false;

    function addLog(msg, isBold=false) {
        if (!isDetectionOn && !msg.includes("System") && !msg.includes("File") && !msg.includes("Reset")) return;
        const area = document.getElementById('infoArea');
        if (!area) return;
        const now = new Date();
        const timeStr = String(now.getHours()).padStart(2,'0') + ":" + String(now.getMinutes()).padStart(2,'0') + ":" + String(now.getSeconds()).padStart(2,'0');
        const line = document.createElement('div');
        line.className = 'log-line';
        line.innerHTML = `<span style="color:#666">[${timeStr}]</span> ${isBold ? '<b>'+msg+'</b>' : msg}`;
        area.insertBefore(line, area.firstChild);
        if(area.children.length > 100) area.removeChild(area.lastChild);
    }

    function toggleDetection() {
        isDetectionOn = !isDetectionOn;
        const wrap = document.getElementById('cwAreaWrap');
        if (isDetectionOn) {
            wrap.classList.remove('disabled');
            addLog("Detection Enabled.");
        } else {
            wrap.classList.add('disabled');
            currentRpm = 0; lastEventStr = "--"; updateUI();
            addLog("Detection Disabled.");
        }
    }

    // --- UPGRADED: Omni-Directional Learning ---
    function processLearning() {
        if (learnBuf.length < 50) { addLog("Learning Failed: Not enough data.", true); return; }
        let sum = {x:0, y:0, z:0}, min = {x:Infinity, y:Infinity, z:Infinity}, max = {x:-Infinity, y:-Infinity, z:-Infinity};
        learnBuf.forEach(d => {
            sum.x+=d.x; sum.y+=d.y; sum.z+=d.z;
            min.x=Math.min(min.x, d.x); max.x=Math.max(max.x, d.x);
            min.y=Math.min(min.y, d.y); max.y=Math.max(max.y, d.y);
            min.z=Math.min(min.z, d.z); max.z=Math.max(max.z, d.z);
        });
        const n = learnBuf.length;
        const dc = {x:sum.x/n, y:sum.y/n, z:sum.z/n};
        learnedParams.dcRef = dc;

        let cpYZ = 0, cpZX = 0, cpXY = 0; // Added cpXY
        for(let i=1; i<n; i++) {
            let c = learnBuf[i], p = learnBuf[i-1];
            let cy = c.y-dc.y, cz = c.z-dc.z, cx = c.x-dc.x;
            let py = p.y-dc.y, pz = p.z-dc.z, px = p.x-dc.x;
            cpYZ += (cy*pz - cz*py);
            cpZX += (cz*px - cx*pz);
            cpXY += (cx*py - cy*px); // New Planar Calc
        }
        
        // 1. Omni-Directional Plane Selection
        const magYZ = Math.abs(cpYZ);
        const magZX = Math.abs(cpZX);
        const magXY = Math.abs(cpXY);
        const maxMag = Math.max(magYZ, magZX, magXY);
        
        let mainCP = 0;
        if (maxMag === magXY) { learnedParams.plane = 'XY'; mainCP = cpXY; }
        else if (maxMag === magYZ) { learnedParams.plane = 'YZ'; mainCP = cpYZ; }
        else { learnedParams.plane = 'ZX'; mainCP = cpZX; }

        learnedParams.cwSign = Math.sign(mainCP);
        
        // 2. Adaptive Threshold (10% of Max Learning CP)
        learnedParams.cpThreshold = Math.abs(mainCP) * 0.1;

        // 3. Dynamic RPM Axis Selection
        const rx = max.x - min.x, ry = max.y - min.y, rz = max.z - min.z;
        if (rx > ry && rx > rz) learnedParams.rpmAxis = 'x';
        else if (ry > rz) learnedParams.rpmAxis = 'y';
        else learnedParams.rpmAxis = 'z';

        learnedParams.isValid = true;
        addLog("Learning Complete.", true);
        document.getElementById('cwDebugInfo').innerText = `P:${learnedParams.plane} S:${learnedParams.cwSign>0?'+':'-'} A:${learnedParams.rpmAxis.toUpperCase()}`;
    }

    // --- UPGRADED: Omni-Directional Runtime ---
    function analyzeWindow() {
        if (!isDetectionOn) return;
        let n = winBuf.length;
        if (n < 2) return;

        // Legacy Fallback (Unlearned)
        if (!learnedParams.isValid) {
            let sum = {x:0, y:0, z:0};
            for(let s of winBuf) { sum.x+=s.x; sum.y+=s.y; sum.z+=s.z; }
            let dc = {x:sum.x/n, y:sum.y/n, z:sum.z/n};
            let cpYZ = 0, cpZX = 0;
            for(let i=1; i<n; i++) {
                let c = winBuf[i], p = winBuf[i-1];
                let cy = c.y-dc.y, cz = c.z-dc.z, cx = c.x-dc.x;
                let py = p.y-dc.y, pz = p.z-dc.z, px = p.x-dc.x;
                cpYZ += (cy*pz - cz*py);
                cpZX += (cz*px - cx*pz);
            }
            let isYZ = Math.abs(cpYZ) > Math.abs(cpZX);
            let mainCP = isYZ ? cpYZ : cpZX;
            if (Math.abs(mainCP) < 0.2) { currentRpm = 0; lastEventStr = "STOP"; updateUI(); return; }
            let gravitySign = (dc.z >= 0) ? 1 : -1;
            let M = mainCP * gravitySign;
            if (dc.x < -0.25) M = -M;
            lastEventStr = (M < 0) ? "正轉 (CW)" : "反轉 (CCW)";
            
            let rpmAxis = isYZ ? 'y' : 'z';
            let meanVal = dc[rpmAxis];
            let zc = 0, lastV = winBuf[0][rpmAxis] - meanVal;
            for (let i=1; i<n; i++) {
                let v = winBuf[i][rpmAxis] - meanVal;
                if ((lastV <= 0 && v > 0) || (lastV >= 0 && v < 0)) zc++;
                lastV = v;
            }
            let dt = (winBuf[n-1].t - winBuf[0].t) / 1000;
            if (dt > 0.1) currentRpm = currentRpm * 0.3 + ((zc/2)/dt*60) * 0.7;
            else currentRpm = (zc/2)*60;
            updateUI();
            return;
        }

        // --- NEW: V.G.2.7.28 LOGIC (Data Time) ---
        let sum = {x:0, y:0, z:0};
        for(let s of winBuf) { sum.x+=s.x; sum.y+=s.y; sum.z+=s.z; }
        let winDC = {x:sum.x/n, y:sum.y/n, z:sum.z/n};

        let cp = 0;
        for(let i=1; i<n; i++) {
            let c = winBuf[i], p = winBuf[i-1];
            let cy = c.y-winDC.y, cz = c.z-winDC.z, cx = c.x-winDC.x;
            let py = p.y-winDC.y, pz = p.z-winDC.z, px = p.x-winDC.x;
            
            // Support ALL 3 Planes
            if (learnedParams.plane === 'XY') cp += (cx*py - cy*px);
            else if (learnedParams.plane === 'YZ') cp += (cy*pz - cz*py);
            else cp += (cz*px - cx*pz);
        }

        // 1. Timeout Check (Using Data Timestamp)
        const currentDataTime = winBuf[n-1].t; // Last point time in buffer
        
        if (Math.abs(cp) > learnedParams.cpThreshold) {
            let isSameSign = (Math.sign(cp) === learnedParams.cwSign);
            lastEventStr = isSameSign ? "正轉 (CW)" : "反轉 (CCW)";
        } else {
            let timeSinceCross = currentDataTime - lastCrossTime;
            if (timeSinceCross > 12000) {
                currentRpm = 0;
                lastEventStr = "STOP";
                hasCrossed = false;
            }
        }

        const axis = learnedParams.rpmAxis;
        const refZero = learnedParams.dcRef[axis];
        let lastV = winBuf[0][axis] - refZero;
        
        // 2. Iterate through buffer to find SPECIFIC crossing times
        for (let i=1; i<n; i++) {
            let v = winBuf[i][axis] - refZero;
            
            // Check for Zero Crossing
            if ((lastV <= 0 && v > 0) || (lastV >= 0 && v < 0)) {
                let crossingTime = winBuf[i].t; // FIX: Use Data Time, not System Time
                
                if (hasCrossed && lastCrossTime > 0) {
                    let dtMs = crossingTime - lastCrossTime; // Accurate interval
                    
                    if (dtMs > 200) { // Debounce noise
                        // Half cycle calc: (60000 ms / dtMs) / 2
                        let rawRpm = 30000 / dtMs;
                        
                        if (currentRpm < 2) currentRpm = rawRpm;
                        else currentRpm = currentRpm * 0.5 + rawRpm * 0.5;
                    }
                }
                lastCrossTime = crossingTime;
                hasCrossed = true;
            }
            lastV = v;
        }
        
        // Debug Log only if significant
        if (Math.abs(cp) > learnedParams.cpThreshold) {
             addLog(`[L] ${learnedParams.plane} | CP:${cp.toFixed(2)} | RPM:${currentRpm.toFixed(1)} | ${lastEventStr}`);
        }
        
        updateUI();
    }

    function updateUI() {
        const el = document.getElementById('cwStatus');
        if (isDetectionOn) el.innerText = lastEventStr;
        else el.innerText = "OFF";
    }

    function animateLoop() {
        requestAnimationFrame(animateLoop);
        const canvas = document.getElementById('rpmCanvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const w = canvas.clientWidth, h = canvas.clientHeight;
        if(canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
        const cx = w/2, cy = h/2, radius = Math.min(w, h)/2 - 25;
        ctx.clearRect(0, 0, w, h);

        let rpm = currentRpm || 0;
        let isCW = (lastEventStr.includes("CW") && !lastEventStr.includes("CCW"));
        let isCCW = lastEventStr.includes("CCW");
        let isStop = (!isCW && !isCCW);

        if (!isDetectionOn) {
            ctx.beginPath(); ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = "#e5e7eb"; ctx.lineWidth = 14; ctx.stroke();
            ctx.fillStyle = "#9ca3af"; ctx.font = "bold 26px Consolas";
            ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("OFF", cx, cy);
            return;
        }

        const LINE_WIDTH = 14;
        ctx.beginPath(); ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
        ctx.strokeStyle = "#f3f4f6"; ctx.lineWidth = LINE_WIDTH; ctx.stroke();

        let color = '#e5e7eb';
        if (!isStop) {
            color = isCW ? '#34d399' : '#fbbf24';
            const now = performance.now();
            const dt = (now - lastAnimTime) / 1000;
            lastAnimTime = now;
            let speed = rpm;
            let dir = isCCW ? -1 : 1;
            let step = (speed / 60) * 2 * Math.PI * dt * dir;
            spinnerAngle += step;
            ctx.beginPath(); ctx.arc(cx, cy, radius, spinnerAngle, spinnerAngle + 1.5 * Math.PI);
            ctx.strokeStyle = color; ctx.lineWidth = LINE_WIDTH; ctx.lineCap = "round"; ctx.stroke();
        } else {
            lastAnimTime = performance.now();
        }

        ctx.fillStyle = isStop ? "#9ca3af" : "#111827";
        ctx.font = "bold 26px Consolas"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(rpm.toFixed(1), cx, cy);
        ctx.font = "11px sans-serif"; ctx.fillStyle = "#9ca3af"; ctx.fillText("RPM", cx, cy + 22);
    }

    function updatePlaybackInfo() {
        const infoDisp = document.getElementById('fileInfoDisplay');
        if (!isLogMode || currentFileName === "") { infoDisp.style.display = 'none'; return; }
        const curSec = Math.floor((playbackIdx * 20) / 1000);
        const totSec = Math.floor((totalLines * 20) / 1000);
        const fmt = (s) => String(Math.floor(s/60)).padStart(2,'0') + ":" + String(s%60).padStart(2,'0');
        infoDisp.innerText = `${currentFileName} | [${fmt(curSec)} / ${fmt(totSec)}]`;
        infoDisp.style.display = 'block';
    }

    function parseLogTimestamp(line) {
        let m = line.match(/\[(\d+):(\d+):(\d+)\.(\d+)\]/);
        if (m) {
            let d = new Date();
            d.setHours(parseInt(m[1]), parseInt(m[2]), parseInt(m[3]), parseInt(m[4]));
            return d.getTime();
        }
        return Date.now();
    }

    function performReset() {
        clearInterval(replayInterval);
        playbackIdx = 0; buffer = []; winBuf = []; offsets = {x:0, y:0, z:0};
        lastEventStr = "--"; currentRpm = 0;
        document.getElementById('cwDebugInfo').innerText = "";
        updateUI();
        const canvas = document.getElementById('chartCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,canvas.width,canvas.height);
        document.getElementById('playBtn').disabled = false;
        document.getElementById('pauseBtn').disabled = true;
        addLog("Auto Reset: Data, Buffer, and Offsets Cleared.");
    }

    function handleData(rx, ry, rz, timeStampMs) {
        if (isRecording) {
            let lx = rx - offsets.x, ly = ry - offsets.y, lz = rz - offsets.z;
            let lt = Math.sqrt(lx**2 + ly**2 + lz**2);
            let ts = new Date().toLocaleTimeString('en-GB', {hour12:false}) + "." + String(Date.now()%1000).padStart(3,'0');
            logBuffer.push(`[${ts}] X:${lx.toFixed(3)} Y:${ly.toFixed(3)} Z:${lz.toFixed(3)} | T:${lt.toFixed(3)}G`);
        }
        
        let nowMs = timeStampMs || Date.now();
        let raw = {x:rx, y:ry, z:rz, t:nowMs};

        if (isLearning) {
            learnBuf.push(raw);
            if (learnBuf.length > 200) {
                isLearning = false;
                document.getElementById('learningBtn').classList.remove('btn-learning-active');
                document.getElementById('learningBtn').innerText = "cw_cal";
                processLearning();
            } else if (learnBuf.length > 50) {
                 let maxZ=-Infinity, minZ=Infinity;
                 learnBuf.forEach(d=>{ maxZ=Math.max(maxZ,d.z); minZ=Math.min(minZ,d.z); });
                 if ((maxZ-minZ) > 0.8) {
                    let mid=(maxZ+minZ)/2;
                    let cross=0, wasAbove=(learnBuf[0].z>mid);
                    for(let i=1;i<learnBuf.length;i++){
                        let isAbove=(learnBuf[i].z>mid);
                        if(wasAbove!==isAbove){ cross++; wasAbove=isAbove; }
                    }
                    if(cross >= 5) {
                        isLearning = false;
                        document.getElementById('learningBtn').classList.remove('btn-learning-active');
                        document.getElementById('learningBtn').innerText = "cw_cal";
                        processLearning();
                    }
                 }
            }
        }

        srCounter++; if (srCounter % srRatio !== 0) return;
        lastRaw = {x:rx, y:ry, z:rz};
        
        let x = rx - offsets.x, y = ry - offsets.y, z = rz - offsets.z;
        const m = document.getElementById('smoothSelect').value;
        const alpha = (m==='low'?0.2:m==='mid'?0.1:m==='high'?0.05:null);
        if (alpha) { smoothed.x += alpha*(x-smoothed.x); smoothed.y += alpha*(y-smoothed.y); smoothed.z += alpha*(z-smoothed.z); }
        else { smoothed.x = x; smoothed.y = y; smoothed.z = z; }
        smoothed.t = Math.sqrt(smoothed.x**2 + smoothed.y**2 + smoothed.z**2);
        
        winBuf.push({x:x, y:y, z:z, t:nowMs});
        
        if (winBuf.length >= WIN_SIZE) {
            analyzeWindow();
            winBuf = [];
        }
        
        const now = Date.now();
        if (trgEnabled && smoothed.t >= trgTh) { if(!trgOnSince) trgOnSince=now; trgOffSince=0; if(!trgState && now-trgOnSince>=200) trgState=true; }
        else { if(!trgOffSince) trgOffSince=now; trgOnSince=0; if(trgState && now-trgOffSince>=200) trgState=false; }
        
        document.getElementById('valX').innerText = smoothed.x.toFixed(3);
        document.getElementById('valY').innerText = smoothed.y.toFixed(3);
        document.getElementById('valZ').innerText = smoothed.z.toFixed(3);
        document.getElementById('valT').innerText = smoothed.t.toFixed(3);
        document.getElementById('totalCard').classList.toggle('triggered-bg', trgState);
        document.getElementById('iRight').classList.toggle('active', smoothed.x < -trgTh);
        document.getElementById('iLeft').classList.toggle('active', smoothed.x > trgTh);
        document.getElementById('iUp').classList.toggle('active', smoothed.y < -trgTh);
        document.getElementById('iDown').classList.toggle('active', smoothed.y > trgTh);
        document.getElementById('iFlip').classList.toggle('active-z', Math.abs(smoothed.z) > 1.0);
        
        buffer.push({...smoothed, isCalib: isLearning});
        if (buffer.length > 300) buffer.shift();
        ['x','y','z','t'].forEach(ax => {
            if (buffer.length < 2) return;
            const data = buffer.slice(-50).map(d => d[ax]);
            document.getElementById('pp'+ax.toUpperCase()).innerText = (Math.max(...data)-Math.min(...data)).toFixed(3);
            document.getElementById('rms'+ax.toUpperCase()).innerText = Math.sqrt(data.reduce((a,b)=>a+b*b,0)/data.length).toFixed(3);
        });
        draw();
    }

    function draw() {
        const canvas = document.getElementById('chartCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width = canvas.clientWidth, h = canvas.height = canvas.clientHeight;
        ctx.clearRect(0,0,w,h);
        
        buffer.forEach((d, i) => {
            if (d.isCalib) {
                const px = i * (w / 300);
                ctx.fillStyle = "rgba(139, 92, 246, 0.2)";
                ctx.fillRect(px, 0, (w/300)+1, h);
            }
        });

        const baseline = h * 0.7;
        if (trgEnabled) { ctx.beginPath(); ctx.strokeStyle="#ddd"; ctx.setLineDash([5,5]); const ty = baseline - (trgTh * h / 5); ctx.moveTo(0,ty); ctx.lineTo(w,ty); ctx.stroke(); ctx.setLineDash([]); }
        ['x','y','z','t'].forEach(ax => {
            if(!document.getElementById('wave'+ax.toUpperCase()).checked) return;
            ctx.beginPath(); ctx.strokeStyle = (ax==='x'?'#ef4444':ax==='y'?'#22c55e':ax==='z'?'#3b82f6':'#000');
            ctx.lineWidth = (ax==='t'?2:1);
            buffer.forEach((d,i)=>{ const px=i*(w/300), py=baseline-(d[ax]*h/5); if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py); }); ctx.stroke();
        });
    }

    window.onload = function() {
        const playBtn = document.getElementById('playBtn'), pauseBtn = document.getElementById('pauseBtn'), resetBtn = document.getElementById('resetBtn');
        const learnBtn = document.getElementById('learningBtn');
        
        document.getElementById('cwAreaWrap').onclick = toggleDetection;

        lastAnimTime = performance.now();
        requestAnimationFrame(animateLoop);

        learnBtn.onclick = function() {
            if (!isLearning) {
                isLearning = true;
                learnBuf = [];
                learnBtn.classList.add('btn-learning-active');
                learnBtn.innerText = "Learning... (Rotate CW)";
                addLog("Learning Started. Please rotate CW (Clockwise)...", true);
            } else {
                isLearning = false;
                learnBtn.classList.remove('btn-learning-active');
                learnBtn.innerText = "cw_cal";
                addLog("Learning Cancelled.");
            }
        };

        document.getElementById('logFileInput').onchange = (e) => {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                logLines = ev.target.result.split('\n').filter(l => l.includes('X:'));
                totalLines = logLines.length; playbackIdx = 0; currentFileName = file.name;
                
                // --- FIX: Enable Reset Button ---
                document.getElementById('resetBtn').disabled = false;
                
                performReset();
                updatePlaybackInfo();
                addLog(`File Loaded: ${file.name}`);
                winBuf = [];
            };
            reader.readAsText(file);
        };

        playBtn.onclick = () => {
            playBtn.disabled = true; pauseBtn.disabled = false;
            replayInterval = setInterval(() => {
                if (playbackIdx >= totalLines) { clearInterval(replayInterval); playBtn.disabled = false; pauseBtn.disabled = true; return; }
                const line = logLines[playbackIdx];
                const m = line.match(/X:([-\d.]+) Y:([-\d.]+) Z:([-\d.]+)/);
                let ts = parseLogTimestamp(line);
                if(m) handleData(parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3]), ts);
                playbackIdx++; if (playbackIdx % 10 === 0) updatePlaybackInfo();
            }, 20);
        };

        pauseBtn.onclick = () => { clearInterval(replayInterval); playBtn.disabled = false; pauseBtn.disabled = true; };
        resetBtn.onclick = performReset;

        document.getElementById('recordBtn').onclick = function() {
            if (!isRecording) {
                isRecording = true; recordStartTime = Date.now();
                logBuffer = ["[GBLE_LOG_START]", `# Header: Exported v.g.2.7.28`, `# Start: ${new Date().toLocaleString()}`];
                this.classList.add('recording');
                recordTimerInt = setInterval(() => {
                    let elapsed = Math.floor((Date.now() - recordStartTime)/1000);
                    let m = String(Math.floor(elapsed/60)).padStart(2,'0'), s = String(elapsed%60).padStart(2,'0');
                    this.innerText = `停止紀錄 (${m}:${s})`;
                }, 1000);
            } else {
                isRecording = false; clearInterval(recordTimerInt);
                this.classList.remove('recording'); this.innerText = "開始紀錄 (00:00)";
                const blob = new Blob([logBuffer.join('\n')], {type:'text/plain'});
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
                
                // --- NEW DATE FORMAT FILENAME ---
                const now = new Date();
                const yy = String(now.getFullYear()).slice(-2);
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const dd = String(now.getDate()).padStart(2, '0');
                const HH = String(now.getHours()).padStart(2, '0');
                const MM = String(now.getMinutes()).padStart(2, '0');
                a.download = `gble_${yy}${mm}${dd}_${HH}${MM}.txt`;
                
                a.click();
            }
        };

        document.getElementById('liveModeBtn').onclick = function() {
            isLogMode=false; this.classList.add('btn-active');
            document.getElementById('logModeBtn').classList.remove('btn-active');
            document.getElementById('liveControls').style.display='flex';
            document.getElementById('logControls').style.display='none';
            document.getElementById('recordBtn').style.display='none';
            updatePlaybackInfo();
        };
        document.getElementById('logModeBtn').onclick = function() {
            isLogMode=true; this.classList.add('btn-active');
            document.getElementById('liveModeBtn').classList.remove('btn-active');
            document.getElementById('liveControls').style.display='none';
            document.getElementById('logControls').style.display='flex';
            updatePlaybackInfo();
        };
        
        document.getElementById('connectBtn').onclick = async () => {
            try {
                const device = await navigator.bluetooth.requestDevice({ filters: [{ services: ['550e8400-e29b-41d4-a716-446655440000'] }] });
                device.addEventListener('gattserverdisconnected', () => { if(isRecording) document.getElementById('recordBtn').click(); addLog("BLE 斷線，已自動存檔。"); });
                const server = await device.gatt.connect();
                const service = await server.getPrimaryService('550e8400-e29b-41d4-a716-446655440000');
                bluetoothChar = await service.getCharacteristic('550e8400-e29b-41d4-a716-446655440001');
                await bluetoothChar.startNotifications();
                bluetoothChar.addEventListener('characteristicvaluechanged',(e)=>{ if(!isLogMode){ const dv=e.target.value; handleData(dv.getFloat32(0,true),dv.getFloat32(4,true),dv.getFloat32(8,true), Date.now()); }});
                addLog("BLE 已連線。");
                document.getElementById('recordBtn').style.display = 'inline-block';
            } catch(e) { addLog("連線失敗: " + e); }
        };
        document.getElementById('calibBtn').onclick = () => { offsets = {...lastRaw}; buffer = []; };
        document.getElementById('srSelect').onchange = (e) => { srRatio = parseInt(e.target.value); };
        document.getElementById('trgSelect').onchange = (e) => { trgEnabled = e.target.value !== 'off'; trgTh = parseFloat(e.target.value); draw(); };
        document.getElementById('waveT').onchange = draw;
        document.getElementById('clearDataBtn').onclick = performReset;
        
        // --- ADDED MISSING LISTENERS FOR X/Y/Z ---
        ['x','y','z'].forEach(ax => document.getElementById('wave'+ax.toUpperCase()).onchange = draw);

        window.onresize = draw;
    };
})();
</script>
</body>
</html>
